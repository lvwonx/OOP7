// MainForm.cpp
#include "MainForm.h"
#include "Manager.h" // Includes the global manager declaration (now with public objects)
#include "Ball.h"
#include "Triangle.h"
#include "Rectangle.h"
#include "Star.h"
#include "Hunter.h" // Need to create Hunter
#include "Animal.h" // Need to create Animals
#include "Tree.h" // Need to create Trees
#include "Explosion.h" // Explosions might be created by manager/objects
#include "Bullet.h" // Bullets are created by Hunter
#include "Pictures.h" // For loading images via the static class

#include <ctime> // For srand
#define _USE_MATH_DEFINES
#include <cmath> // For M_PI, cos, sin, atan2, sqrt

using namespace OOP5_Asorti;
using namespace System::Drawing;
using namespace System::Windows::Forms;
using namespace System::Diagnostics; // For Debug output

// Define and initialize global unmanaged manager pointer (should be defined once in a .cpp file)
Manager* manager = nullptr;

// NOTE: Static managed member MainForm::form is now initialized in MainForm.h


// --- BEGIN InitializeComponent (Paste the full implementation here) ---
// This code is typically generated by the Form Designer.
// Ensure all your controls (PictureBox, GroupBox, RadioButtons, Labels, Buttons) are declared in MainForm.h
// and initialized and added to the Controls collection in this function.
void MainForm::InitializeComponent(void) {
    this->components = gcnew System::ComponentModel::Container(); // Make sure components is initialized

    // DECLARATIONS (These should also be in MainForm.h, listing them here for clarity of InitializeComponent's role)
    // System::Windows::Forms::PictureBox^ pop_frame;
    // System::Windows::Forms::GroupBox^ shapeGroupBox;
    // ... (radio buttons, shape labels) ...
    // System::Windows::Forms::Label^ bulletsLabel;
    // System::Windows::Forms::Label^ bulletsCountLabel;
    // System::Windows::Forms::Label^ trophiesLabel;
    // System::Windows::Forms::Label^ trophiesCountLabel;
    // System::Windows::Forms::Button^ startButton;
    // System::Windows::Forms::Button^ stopButton;


    // INITIALIZATION (Allocate memory for controls)
    this->pop_frame = (gcnew System::Windows::Forms::PictureBox());
    this->shapeGroupBox = (gcnew System::Windows::Forms::GroupBox());
    this->starBtn = (gcnew System::Windows::Forms::RadioButton());
    this->triangleBtn = (gcnew System::Windows::Forms::RadioButton());
    this->rectangleBtn = (gcnew System::Windows::Forms::RadioButton());
    this->ballBtn = (gcnew System::Windows::Forms::RadioButton());
    this->ballLabel = (gcnew System::Windows::Forms::Label());
    this->ballCountLabel = (gcnew System::Windows::Forms::Label());
    this->rectangleLabel = (gcnew System::Windows::Forms::Label());
    this->rectangleCountLabel = (gcnew System::Windows::Forms::Label());
    this->triangleLabel = (gcnew System::Windows::Forms::Label());
    this->triangleCountLabel = (gcnew System::Windows::Forms::Label());
    this->starLabel = (gcnew System::Windows::Forms::Label());
    this->starCountLabel = (gcnew System::Windows::Forms::Label());

    // Initialize new game-specific labels and buttons
    this->bulletsLabel = (gcnew System::Windows::Forms::Label());
    this->bulletsCountLabel = (gcnew System::Windows::Forms::Label());
    this->trophiesLabel = (gcnew System::Windows::Forms::Label());
    this->trophiesCountLabel = (gcnew System::Windows::Forms::Label());
    this->startButton = (gcnew System::Windows::Forms::Button());
    this->stopButton = (gcnew System::Windows::Forms::Button());


    // BEGIN/END INIT (Standard designer code)
    (cli::safe_cast<System::ComponentModel::ISupportInitialize^>(this->pop_frame))->BeginInit();
    this->shapeGroupBox->SuspendLayout();
    this->SuspendLayout();

    // --- pop_frame setup ---
    this->pop_frame->Anchor = static_cast<System::Windows::Forms::AnchorStyles>(((System::Windows::Forms::AnchorStyles::Top | System::Windows::Forms::AnchorStyles::Bottom)
        | System::Windows::Forms::AnchorStyles::Left)
        | System::Windows::Forms::AnchorStyles::Right);
    this->pop_frame->BackColor = System::Drawing::Color::LightCyan;
    this->pop_frame->BorderStyle = System::Windows::Forms::BorderStyle::FixedSingle;
    this->pop_frame->Location = System::Drawing::Point(12, 12);
    this->pop_frame->Name = L"pop_frame";
    this->pop_frame->Size = System::Drawing::Size(600, 400); // Adjust size as needed
    this->pop_frame->TabIndex = 0;
    this->pop_frame->TabStop = false;
    // Hook up event handlers
    this->pop_frame->Paint += gcnew System::Windows::Forms::PaintEventHandler(this, &MainForm::pop_frame_Paint);
    this->pop_frame->MouseDown += gcnew System::Windows::Forms::MouseEventHandler(this, &MainForm::pop_frame_MouseDown);
    this->pop_frame->MouseUp += gcnew System::Windows::Forms::MouseEventHandler(this, &MainForm::pop_frame_MouseUp); // Your code had this
    this->pop_frame->MouseMove += gcnew System::Windows::Forms::MouseEventHandler(this, &MainForm::pop_frame_MouseMove); // Hook up MouseMove

    // --- shapeGroupBox and RadioButtons setup ---
    this->shapeGroupBox->Anchor = static_cast<System::Windows::Forms::AnchorStyles>((System::Windows::Forms::AnchorStyles::Top | System::Windows::Forms::AnchorStyles::Right));
    this->shapeGroupBox->Controls->Add(this->starBtn);
    this->shapeGroupBox->Controls->Add(this->triangleBtn);
    this->shapeGroupBox->Controls->Add(this->rectangleBtn);
    this->shapeGroupBox->Controls->Add(this->ballBtn);
    this->shapeGroupBox->Location = System::Drawing::Point(620, 12); // Adjust position
    this->shapeGroupBox->Name = L"shapeGroupBox";
    this->shapeGroupBox->Size = System::Drawing::Size(150, 130); // Adjust size
    this->shapeGroupBox->TabIndex = 1;
    this->shapeGroupBox->TabStop = false;
    this->shapeGroupBox->Text = L"Shape";

    // ... (setup for ballBtn, rectangleBtn, triangleBtn, starBtn location, size, text, etc.) ...
    this->ballBtn->AutoSize = true; this->ballBtn->Location = System::Drawing::Point(15, 25); this->ballBtn->Name = L"ballBtn"; this->ballBtn->Size = System::Drawing::Size(51, 20); this->ballBtn->TabIndex = 0; this->ballBtn->TabStop = true; this->ballBtn->Text = L"Ball"; this->ballBtn->UseVisualStyleBackColor = true;
    this->rectangleBtn->AutoSize = true; this->rectangleBtn->Location = System::Drawing::Point(15, 50); this->rectangleBtn->Name = L"rectangleBtn"; this->rectangleBtn->Size = System::Drawing::Size(90, 20); this->rectangleBtn->TabIndex = 1; this->rectangleBtn->TabStop = true; this->rectangleBtn->Text = L"Rectangle"; this->rectangleBtn->UseVisualStyleBackColor = true;
    this->triangleBtn->AutoSize = true; this->triangleBtn->Location = System::Drawing::Point(15, 75); this->triangleBtn->Name = L"triangleBtn"; this->triangleBtn->Size = System::Drawing::Size(77, 20); this->triangleBtn->TabIndex = 2; this->triangleBtn->TabStop = true; this->triangleBtn->Text = L"Triangle"; this->triangleBtn->UseVisualStyleBackColor = true;
    this->starBtn->AutoSize = true; this->starBtn->Location = System::Drawing::Point(15, 100); this->starBtn->Name = L"starBtn"; this->starBtn->Size = System::Drawing::Size(54, 20); this->starBtn->TabIndex = 3; this->starBtn->TabStop = true; this->starBtn->Text = L"Star"; this->starBtn->UseVisualStyleBackColor = true;


    // --- Shape Count Labels setup ---
    // ... (setup for ballLabel, ballCountLabel, rectangleLabel, etc. locations, sizes, text) ...
    this->ballLabel->AutoSize = true; this->ballLabel->Location = System::Drawing::Point(620, 150); this->ballLabel->Name = L"ballLabel"; this->ballLabel->Size = System::Drawing::Size(35, 16); this->ballLabel->TabIndex = 2; this->ballLabel->Text = L"Balls:";
    this->ballCountLabel->AutoSize = true; this->ballCountLabel->Location = System::Drawing::Point(700, 150); this->ballCountLabel->Name = L"ballCountLabel"; this->ballCountLabel->Size = System::Drawing::Size(14, 16); this->ballCountLabel->TabIndex = 3; this->ballCountLabel->Text = L"0";
    this->rectangleLabel->AutoSize = true; this->rectangleLabel->Location = System::Drawing::Point(620, 170); this->rectangleLabel->Name = L"rectangleLabel"; this->rectangleLabel->Size = System::Drawing::Size(72, 16); this->rectangleLabel->TabIndex = 4; this->rectangleLabel->Text = L"Rectangles:";
    this->rectangleCountLabel->AutoSize = true; this->rectangleCountLabel->Location = System::Drawing::Point(700, 170); this->rectangleCountLabel->Name = L"rectangleCountLabel"; this->rectangleCountLabel->Size = System::Drawing::Size(14, 16); this->rectangleCountLabel->TabIndex = 5; this->rectangleCountLabel->Text = L"0";
    this->triangleLabel->AutoSize = true; this->triangleLabel->Location = System::Drawing::Point(620, 190); this->triangleLabel->Name = L"triangleLabel"; this->triangleLabel->Size = System::Drawing::Size(63, 16); this->triangleLabel->TabIndex = 6; this->triangleLabel->Text = L"Triangles:";
    this->triangleCountLabel->AutoSize = true; this->triangleCountLabel->Location = System::Drawing::Point(700, 190); this->triangleCountLabel->Name = L"triangleCountLabel"; this->triangleCountLabel->Size = System::Drawing::Size(14, 16); this->triangleCountLabel->TabIndex = 7; this->triangleCountLabel->Text = L"0";
    this->starLabel->AutoSize = true; this->starLabel->Location = System::Drawing::Point(620, 210); this->starLabel->Name = L"starLabel"; this->starLabel->Size = System::Drawing::Size(42, 16); this->starLabel->TabIndex = 8; this->starLabel->Text = L"Stars:";
    this->starCountLabel->AutoSize = true; this->starCountLabel->Location = System::Drawing::Point(700, 210); this->starCountLabel->Name = L"starCountLabel"; this->starCountLabel->Size = System::Drawing::Size(14, 16); this->starCountLabel->TabIndex = 9; this->starCountLabel->Text = L"0";


    // --- Game Count Labels setup ---
    this->bulletsLabel->AutoSize = true; this->bulletsLabel->Location = System::Drawing::Point(620, 240); this->bulletsLabel->Name = L"bulletsLabel"; this->bulletsLabel->Size = System::Drawing::Size(50, 16); this->bulletsLabel->TabIndex = 10; this->bulletsLabel->Text = L"Bullets:";
    this->bulletsCountLabel->AutoSize = true; this->bulletsCountLabel->Location = System::Drawing::Point(700, 240); this->bulletsCountLabel->Name = L"bulletsCountLabel"; this->bulletsCountLabel->Size = System::Drawing::Size(14, 16); this->bulletsCountLabel->TabIndex = 11; this->bulletsCountLabel->Text = L"0";
    this->trophiesLabel->AutoSize = true; this->trophiesLabel->Location = System::Drawing::Point(620, 260); this->trophiesLabel->Name = L"trophiesLabel"; this->trophiesLabel->Size = System::Drawing::Size(67, 16); this->trophiesLabel->TabIndex = 12; this->trophiesLabel->Text = L"Trophies:";
    this->trophiesCountLabel->AutoSize = true; this->trophiesCountLabel->Location = System::Drawing::Point(700, 260); this->trophiesCountLabel->Name = L"trophiesCountLabel"; this->trophiesCountLabel->Size = System::Drawing::Size(14, 16); this->trophiesCountLabel->TabIndex = 13; this->trophiesCountLabel->Text = L"0";


    // --- Buttons setup ---
    this->startButton->Location = System::Drawing::Point(620, 300); this->startButton->Name = L"startButton"; this->startButton->Size = System::Drawing::Size(150, 30); this->startButton->TabIndex = 14; this->startButton->Text = L"Start Game"; this->startButton->UseVisualStyleBackColor = true;
    this->stopButton->Location = System::Drawing::Point(620, 340); this->stopButton->Name = L"stopButton"; this->stopButton->Size = System::Drawing::Size(150, 30); this->stopButton->TabIndex = 15; this->stopButton->Text = L"Stop Game"; this->stopButton->UseVisualStyleBackColor = true; this->stopButton->Enabled = false; // Start with Stop disabled



    // --- Add controls to Form ---
    this->Controls->Add(this->stopButton);
    this->Controls->Add(this->startButton);
    this->Controls->Add(this->trophiesCountLabel);
    this->Controls->Add(this->trophiesLabel);
    this->Controls->Add(this->bulletsCountLabel);
    this->Controls->Add(this->bulletsLabel);
    this->Controls->Add(this->starCountLabel);
    this->Controls->Add(this->starLabel);
    this->Controls->Add(this->triangleCountLabel);
    this->Controls->Add(this->triangleLabel);
    this->Controls->Add(this->rectangleCountLabel);
    this->Controls->Add(this->rectangleLabel);
    this->Controls->Add(this->ballCountLabel);
    this->Controls->Add(this->ballLabel);
    this->Controls->Add(this->shapeGroupBox);
    this->Controls->Add(this->pop_frame);


    // --- Form setup ---
    this->AutoScaleDimensions = System::Drawing::SizeF(8, 16);
    this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
    this->ClientSize = System::Drawing::Size(782, 423); // Adjust size as needed
    this->FormBorderStyle = System::Windows::Forms::FormBorderStyle::Fixed3D;
    this->Name = L"MainForm";
    this->StartPosition = System::Windows::Forms::FormStartPosition::CenterScreen;
    this->Text = L"Pop Shapes V6: Mednieks"; // Updated title
    this->KeyPreview = true; // Ensure form receives key events


    // END INIT (Standard designer code)
    (cli::safe_cast<System::ComponentModel::ISupportInitialize^>(this->pop_frame))->EndInit();
    this->shapeGroupBox->ResumeLayout(false);
    this->shapeGroupBox->PerformLayout();
    this->ResumeLayout(false);
    this->PerformLayout();

}
// --- END InitializeComponent ---


// --- Constructor Implementation ---
MainForm::MainForm(void) {
    // Set the static form pointer FIRST (Section 7.3 & 7.9.3)
    MainForm::form = this;

    // Initialize UI components (from designer)
    InitializeComponent();

    // Initialize random seed (do this once in the application)
    srand(static_cast<unsigned int>(time(0)));

    // Initialize the global manager AFTER controls are created and their dimensions are known
    // Check if pop_frame is valid before using its dimensions
    if (pop_frame != nullptr) {
        ::manager = new Manager(pop_frame->Width, pop_frame->Height); // Uses pop_frame dimensions
    }
    else {
        // Fallback: Use default size if pop_frame is null (shouldn't happen in a normal scenario)
        ::manager = new Manager(800, 600); // Use default size if pop_frame is null
        Debug::WriteLine("Error: pop_frame was null during Manager initialization!");
    }


    // Setup move timer
    moveTimer = gcnew Timer();
    moveTimer->Interval = 20; // Milliseconds per tick (adjust as needed)
    moveTimer->Tick += gcnew EventHandler(this, &MainForm::OnMoveTimer);
    // Timers are started in startGame()

    // Setup draw timer
    drawTimer = gcnew Timer();
    drawTimer->Interval = 20; // Milliseconds per tick (adjust as needed)
    drawTimer->Tick += gcnew EventHandler(this, &MainForm::OnDrawTimer);
    // Timers are started in startGame()

    // Hook up Key and Mouse Wheel event handlers (already in your code)
    this->startButton->Click += gcnew System::EventHandler(this, &MainForm::startButton_Click);
    this->KeyPreview = true;
    this->KeyDown += gcnew KeyEventHandler(this, &MainForm::MainForm_KeyDown);
    this->KeyUp += gcnew KeyEventHandler(this, &MainForm::MainForm_KeyUp);
    this->MouseWheel += gcnew MouseEventHandler(this, &MainForm::OnMouseWheel);
    // MouseMove hooked up in InitializeComponent

    // Set default selected shape radio button
    this->ballBtn->Checked = true;

    // Initialize game state counts
    bulletsCount = 0; // Game starts with 0 bullets until startGame
    trophiesCount = 0;

    // Initial UI update
    UpdateCountLabels();

    // Game doesn't start automatically, waits for Start button click
}

// --- Destructor Implementation ---
MainForm::~MainForm() {
    // Stop timers FIRST
    if (moveTimer != nullptr) {
        moveTimer->Stop();
        delete moveTimer; // Clean up managed object
        moveTimer = nullptr;
    }
    if (drawTimer != nullptr) {
        drawTimer->Stop();
        delete drawTimer; // Clean up managed object
        drawTimer = nullptr;
    }
    // Clean up game timer if you added one

    // Delete unmanaged manager and its contents (calls Manager's destructor, which calls destroyAll)
    if (manager != nullptr) {
        delete manager;
        manager = nullptr;
    }

    // Dispose components (managed controls and designer stuff) LAST
    if (components) {
        delete components; // This calls Dispose() on managed components
    }
}

// --- Helper to update all count labels ---
void MainForm::UpdateCountLabels() {
    // Update shape counts (from your original code)
    if (manager != nullptr) { // Ensure manager is valid
        if (ballCountLabel != nullptr)  ballCountLabel->Text = manager->countBalls().ToString();
        if (rectangleCountLabel != nullptr) rectangleCountLabel->Text = manager->countRectangles().ToString();
        if (triangleCountLabel != nullptr) triangleCountLabel->Text = manager->countTriangles().ToString();
        if (starCountLabel != nullptr)  starCountLabel->Text = manager->countStars().ToString();
    }
    else {
        // Set to 0 or error indicator if manager is null
        if (ballCountLabel != nullptr)  ballCountLabel->Text = "N/A";
        if (rectangleCountLabel != nullptr) rectangleCountLabel->Text = "N/A";
        if (triangleCountLabel != nullptr) triangleCountLabel->Text = "N/A";
        if (starCountLabel != nullptr)  starCountLabel->Text = "N/A";
    }


    // Update game-specific counts (Bullets, Trophies)
    if (bulletsCountLabel != nullptr) bulletsCountLabel->Text = bulletsCount.ToString();
    if (trophiesCountLabel != nullptr) trophiesCountLabel->Text = trophiesCount.ToString();

    // Update game timer label if you added one
}

// --- Game State Management Methods Implementation (Section 7.8 & 7.9.10) ---

bool MainForm::takeBullet() {
    // Called by Hunter before shooting
    if (bulletsCount > 0) {
        bulletsCount--;
        UpdateCountLabels();
        return true;
    }
    else {
        // No bullets left, end the game
        endGame(1); // Reason 1: Out of bullets
        return false;
    }
}

void MainForm::killAnimal() {
    // Called by Bullet when it hits an Animal
    trophiesCount++;
    // According to PDF Section 7.8:
    // - increase trophy count (done)
    // - replenish bullets (e.g., gain bullets)
    // - add a new animal

    bulletsCount += 3; // Example: Gain 3 bullets
    Debug::WriteLine("Animal killed! Trophies: " + trophiesCount + ", Bullets replenished.");


    // Add a new Animal at a random position
    if (manager != nullptr && pop_frame != nullptr) {
        // Ensure we don't exceed MAX_OBJECTS or a specific Animal limit
        // You might want a MAX_ANIMALS define
        manager->add(new Animal(pop_frame->Width, pop_frame->Height, rand() % pop_frame->Width, rand() % pop_frame->Height));
    }

    UpdateCountLabels();

    // Check for win condition (e.g., reaching a certain number of trophies)
    // if (trophiesCount >= 10) { // Example win condition
    //    // endGame(2); // Reason 2: Win
    // }
}

void MainForm::startGame() {
    if (manager == nullptr || pop_frame == nullptr) {
        Debug::WriteLine("Cannot start game: manager or pop_frame is null.");
        return;
    }
    Debug::WriteLine("Starting game...");

    // Reset game state variables
    bulletsCount = 50; // Starting bullets (adjust as needed)
    trophiesCount = 0;
    // Reset game timer if you have one

    // Clear all existing objects from the previous game (calls destructors and creates explosions)
    manager->destroyAll();
    // Wait a moment for explosions to clear or add objects after explosions finish?
    // For simplicity, add objects immediately after destroyAll.
    // If explosions have a life time, they will continue to animate and remove themselves.
    // Create and add initial game objects for a new game
    // Add Hunter (assuming only one)
    Hunter* playerHunter = new Hunter(pop_frame->Width, pop_frame->Height, pop_frame->Width / 2, pop_frame->Height / 2);
    manager->add(playerHunter);
    // You might want to store the playerHunter pointer in a member variable if you need to access it directly often (e.g., for MouseMove)

    // Add some initial Animals and Trees
    for (int i = 0; i < 5; ++i) { // Adjust initial counts
        manager->add(new Animal(pop_frame->Width, pop_frame->Height, rand() % pop_frame->Width, rand() % pop_frame->Height));
        manager->add(new Tree(pop_frame->Width, pop_frame->Height, rand() % pop_frame->Width, rand() % pop_frame->Height));
    }
    // Add some initial "knišļi" (shapes)
    for (int i = 0; i < 5; ++i) { // Adjust initial counts
        manager->add(new Ball(pop_frame->Width, pop_frame->Height, rand() % pop_frame->Width, rand() % pop_frame->Height));
        manager->add(new Triangle(pop_frame->Width, pop_frame->Height, rand() % pop_frame->Width, rand() % pop_frame->Height));
        manager->add(new ::Rectangle(pop_frame->Width, pop_frame->Height, rand() % pop_frame->Width, rand() % pop_frame->Height));
        manager->add(new Star(pop_frame->Width, pop_frame->Height, rand() % pop_frame->Width, rand() % pop_frame->Height));
    }


    UpdateCountLabels(); // Update UI after adding objects

    // Start game timers
    moveTimer->Start();
    drawTimer->Start();
    // gameTimer->Start();

    // Update button states (Start disabled, Stop enabled)
    if (startButton != nullptr) startButton->Enabled = false;
    if (stopButton != nullptr) stopButton->Enabled = true;

    Debug::WriteLine("Game Started! Initial Bullets: " + bulletsCount);
}

void MainForm::endGame(int reason) {
    Debug::WriteLine("Ending game. Reason: " + reason);

    // Stop game timers
    if (moveTimer != nullptr) moveTimer->Stop();
    if (drawTimer != nullptr) drawTimer->Stop();
    // gameTimer->Stop();

    // Update button states (Start enabled, Stop disabled)
    if (startButton != nullptr) startButton->Enabled = true;
    if (stopButton != nullptr) stopButton->Enabled = false;

    // Display end game message based on reason
    String^ message;
    String^ caption = "Game Over";
    switch (reason) {
    case 0: // Hunter killed
        message = "Game Over! Hunter was killed.\n\nTrophies collected: " + trophiesCount.ToString();
        break;
    case 1: // Out of bullets
        message = "Game Over! Out of bullets.\n\nTrophies collected: " + trophiesCount.ToString();
        break;
    case -1: // User stopped
        message = "Game Stopped by User.\n\nTrophies collected: " + trophiesCount.ToString();
        caption = "Game Stopped";
        break;
    case 2: // Win condition (e.g., killed enough animals)
        message = "Congratulations! You won!\n\nTrophies collected: " + trophiesCount.ToString();
        caption = "Game Won!";
        break;
    default: // Other reason
        message = "Game Over!\n\nTrophies collected: " + trophiesCount.ToString();
        break;
    }

    // Show message box (can be replaced with updating a status label)
    MessageBox::Show(message, caption, MessageBoxButtons::OK);

    // Optional: Clear all objects on game over screen, or wait for next startGame
    // manager->destroyAll(); // This would clear the screen immediately
    // UpdateCountLabels(); // Update UI if clearing
    // if (pop_frame != nullptr) pop_frame->Invalidate(); // Redraw empty frame
}

// --- Event Handlers Implementation ---

void MainForm::OnMoveTimer(Object^ sender, EventArgs^ e) {
    // Defensive check if the form is disposing
    if (this->IsDisposed || this->Disposing) return;

    // Pause game logic if Ctrl is pressed (example from your code)
    if (!ctrlKeyPressed && manager != nullptr && moveTimer->Enabled) { // Only move if game is running
        manager->move();

        // Update UI counts after movement and potential interactions
        UpdateCountLabels();

        // Check for game over conditions periodically if they don't trigger endGame directly
        // Example: Check if the Hunter object still exists in the manager's collection
        bool hunterExists = false;
        if (manager != nullptr) {
            // Access the public objects array directly
            for (int i = 0; i < Manager::MaxObjects; ++i) { // Use Manager::MaxObjects if defined or MAX_OBJECTS directly
                if (manager->objects[i] != nullptr && dynamic_cast<Hunter*>(manager->objects[i]) != nullptr) {
                    hunterExists = true;
                    break;
                }
            }
        }

        if (!hunterExists && moveTimer->Enabled) { // Check timer enabled to avoid multiple calls
            endGame(0); // Reason 0: Hunter killed
        }
    }
}

// OnDrawTimer and pop_frame_Paint remain the same as your code
void MainForm::OnDrawTimer(Object^ sender, EventArgs^ e) {
    if (this->IsDisposed || this->Disposing) return;
    if (pop_frame != nullptr) pop_frame->Invalidate(); // Request redraw
}

void MainForm::pop_frame_Paint(Object^ sender, PaintEventArgs^ e) {
    // Ensure form, event args, and graphics object are valid
    if (this->IsDisposed || this->Disposing || e == nullptr || e->Graphics == nullptr) return;

    Graphics^ g = e->Graphics;
    g->SmoothingMode = SmoothingMode::AntiAlias; // For smoother shapes/lines
    if (manager != nullptr) {
        manager->drawFrame(g); // Delegate drawing to the manager
    }
}


// Mouse handlers
void MainForm::pop_frame_MouseDown(Object^ sender, MouseEventArgs^ e) {
    if (this->IsDisposed || this->Disposing) return;

    // In the game mode, left click is usually for shooting, not adding shapes.
    // Right click is often ignored or used for a secondary action.
    // Let's keep the shape adding/removing for testing purposes outside the game loop,
    // but the main game logic should likely use a different mechanism for shooting (e.g., Spacebar).

    if (e->Button == System::Windows::Forms::MouseButtons::Left) {
        // Code to add shapes (from your original code, adapted slightly)
        if (manager == nullptr || !moveTimer->Enabled) { // Allow adding shapes only when game is not running (timers stopped)
            PopObject* newObject = nullptr;
            int clickX = e->X;
            int clickY = e->Y;
            int width = (pop_frame != nullptr) ? pop_frame->Width : 0;
            int height = (pop_frame != nullptr) ? pop_frame->Height : 0;

            if (width == 0 || height == 0) return;

            // Check limits (example limits)
            if (ballBtn->Checked) { if (manager->countBalls() < 20) newObject = new Ball(width, height, clickX, clickY); }
            else if (rectangleBtn->Checked) { if (manager->countRectangles() < 20) newObject = new ::Rectangle(width, height, clickX, clickY); }
            else if (triangleBtn->Checked) { if (manager->countTriangles() < 20) newObject = new Triangle(width, height, clickX, clickY); }
            else if (starBtn->Checked) { if (manager->countStars() < 20) newObject = new Star(width, height, clickX, clickY); }
            // Add Animal/Tree creation if you want to manually place them too
            // else if (animalBtn->Checked) { if (manager->countAnimals() < ...) newObject = new Animal(...) }


            if (newObject != nullptr && manager != nullptr) {
                // Add some random initial speed to manually added objects
                float speed = (static_cast<float>(rand()) / RAND_MAX * 5.0f + 1.0f); // Speed 1.0 to 6.0
                float angle = static_cast<float>(rand()) / RAND_MAX * 2.0f * static_cast<float>(M_PI);
                newObject->setSpeed(speed * cos(angle), speed * sin(angle));

                manager->add(newObject);
                // Invalidate happens via DrawTimer
            }
            else if (newObject != nullptr) {
                delete newObject; // Clean up if not added
            }
        }
    }
    else if (e->Button == System::Windows::Forms::MouseButtons::Right) {
        // Code to remove objects (from your original code, adapted)
        // Allow removing shapes/animals/trees when game is not running
        if (manager != nullptr && !moveTimer->Enabled) {
            PopObject* target = manager->search(e->X, e->Y);
            if (target) {
                // Prevent removing the Hunter or other critical game objects if they exist
                if (dynamic_cast<Hunter*>(target) == nullptr) { // Don't remove the Hunter manually
                    manager->remove(target);
                    // Invalidate happens via DrawTimer
                }
            }
        }
    }
}

void MainForm::pop_frame_MouseUp(Object^ sender, MouseEventArgs^ e) {
    if (this->IsDisposed || this->Disposing) return;
    // Your original code had right-click removal here too. Decided to put it in MouseDown for simplicity.
}

void MainForm::pop_frame_MouseMove(Object^ sender, MouseEventArgs^ e) {
    if (this->IsDisposed || this->Disposing) return;

    // Update Hunter's aim position if the game is running and Hunter exists
    // Find the Hunter object in the manager's collection (assuming only one)
    if (manager != nullptr && moveTimer->Enabled) { // Only track aim if game is running
        PopObject* hunterObj = nullptr;
        // Access the public objects array directly
        for (int i = 0; i < Manager::MaxObjects; ++i) { // Use Manager::MaxObjects or MAX_OBJECTS directly
            if (manager->objects[i] != nullptr && dynamic_cast<Hunter*>(manager->objects[i]) != nullptr) {
                hunterObj = manager->objects[i];
                break; // Found the hunter
            }
        }

        if (hunterObj != nullptr) {
            Hunter* playerHunter = dynamic_cast<Hunter*>(hunterObj);
            if (playerHunter != nullptr) {
                // MouseEventArgs e already gives client coordinates relative to the control it happened on (pop_frame)
                playerHunter->setAimPosition(static_cast<float>(e->X), static_cast<float>(e->Y));
            }
        }
    }
}


// Keyboard handlers
void MainForm::MainForm_KeyDown(Object^ sender, KeyEventArgs^ e) {
    if (this->IsDisposed || this->Disposing) return;

    // Process commands only if game is running OR if it's a global command (like 'D' or Ctrl)
    bool isGameRunning = (manager != nullptr && moveTimer->Enabled);

    if (isGameRunning) {
        // Find the Hunter object and send commands
        PopObject* hunterObj = nullptr;
        // Access the public objects array directly
        for (int i = 0; i < Manager::MaxObjects; ++i) { // Use Manager::MaxObjects or MAX_OBJECTS directly
            if (manager->objects[i] != nullptr && dynamic_cast<Hunter*>(manager->objects[i]) != nullptr) {
                hunterObj = manager->objects[i];
                break;
            }
        }

        if (hunterObj != nullptr) {
            // Send movement commands to the Hunter (CMD_START_...)
            if (e->KeyCode == Keys::Up) hunterObj->doCommand(CMD_START_UP);
            else if (e->KeyCode == Keys::Down) hunterObj->doCommand(CMD_START_DOWN);
            else if (e->KeyCode == Keys::Left) hunterObj->doCommand(CMD_START_LEFT);
            else if (e->KeyCode == Keys::Right) hunterObj->doCommand(CMD_START_RIGHT);
            else if (e->KeyCode == Keys::Space) {
                // Shoot command - Hunter will call takeBullet internally if implemented that way
                hunterObj->doCommand(CMD_SHOOT);
                // Bullet count UI updates automatically via takeBullet
            }
        }
    }

    // Global commands regardless of game state or Hunter existence
    if (e->KeyCode == Keys::ControlKey) {
        ctrlKeyPressed = true;
        // Optional: Pause/Resume all objects if Ctrl is pressed
        // manager->doCommand(CMD_TOGGLE_PAUSE_ALL); // Define and implement this
    }
    // Example: Add 'D' key to trigger destroyAll regardless of game state
    else if (e->KeyCode == Keys::D) {
        if (manager != nullptr) {
            manager->destroyAll();
            UpdateCountLabels(); // Update counts after destroying objects
        }
    }
}

void MainForm::MainForm_KeyUp(Object^ sender, KeyEventArgs^ e) {
    if (this->IsDisposed || this->Disposing) return;

    // Process commands only if game is running OR if it's a global command (like Ctrl)
    bool isGameRunning = (manager != nullptr && moveTimer->Enabled);

    if (isGameRunning) {
        // Find the Hunter object and send stop commands
        PopObject* hunterObj = nullptr;
        // Access the public objects array directly
        for (int i = 0; i < Manager::MaxObjects; ++i) { // Use Manager::MaxObjects or MAX_OBJECTS directly
            if (manager->objects[i] != nullptr && dynamic_cast<Hunter*>(manager->objects[i]) != nullptr) {
                hunterObj = manager->objects[i];
                break;
            }
        }

        if (hunterObj != nullptr) {
            // Send stop commands to the Hunter (CMD_STOP_...)
            if (e->KeyCode == Keys::Up) hunterObj->doCommand(CMD_STOP_UP);
            else if (e->KeyCode == Keys::Down) hunterObj->doCommand(CMD_STOP_DOWN);
            else if (e->KeyCode == Keys::Left) hunterObj->doCommand(CMD_STOP_LEFT);
            else if (e->KeyCode == Keys::Right) hunterObj->doCommand(CMD_STOP_RIGHT);
        }
    }

    // Global commands regardless of game state
    if (e->KeyCode == Keys::ControlKey) {
        ctrlKeyPressed = false;
        // Optional: Resume all objects if Ctrl is released
        // manager->doCommand(CMD_TOGGLE_PAUSE_ALL);
    }
}

void MainForm::OnMouseWheel(Object^ sender, MouseEventArgs^ e) {
    if (this->IsDisposed || this->Disposing) return;

    // Scale speed for all objects via manager
    if (manager != nullptr) {
        float factor = (e->Delta > 0) ? 1.1f : 0.9f; // Increase speed on wheel up, decrease on wheel down
        manager->scaleSpeed(factor);
    }
}

// --- Button Event Handlers Implementation ---
void MainForm::startButton_Click(Object^ sender, EventArgs^ e) {
    // Start the game when the Start button is clicked
    if (manager != nullptr && !moveTimer->Enabled) { // Prevent starting if already running
        startGame();
    }
}

void MainForm::stopButton_Click(Object^ sender, EventArgs^ e) {
    // Stop the game when the Stop button is clicked (User initiated stop)
    if (manager != nullptr && moveTimer->Enabled) { // Only stop if game is running
        endGame(-1); // Reason -1: User stopped
    }
}


// --- Main Entry Point ---
#pragma comment(linker, "/subsystem:windows /ENTRY:mainCRTStartup")

// Include necessary headers for main (already included above)
// #include "MainForm.h"
// #include "Manager.h" // Includes the global declaration

[System::STAThreadAttribute] // Required for Windows Forms
int main() {
    // Enable visual styles for a better look
    Application::EnableVisualStyles();
    // Set default text rendering compatibility
    Application::SetCompatibleTextRenderingDefault(false);

    // Create the main form instance. The manager is initialized inside its constructor.
    MainForm^ form = gcnew MainForm();

    // Run the application, showing the main form
    Application::Run(form);

    // Resources (manager and its objects) are cleaned up in the MainForm destructor
    // when the form is closed.

    return 0;
}